<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Share</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">🔗 P2P File Share</h1>
            <p class="text-gray-600">Share files directly between browsers using WebRTC</p>
        </div>

        <!-- Connection Status -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Connection</h2>
                <div id="status" class="px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-600">
                    Initializing...
                </div>
            </div>
            
            <!-- Room Controls -->
            <div class="grid md:grid-cols-2 gap-4 mb-4">
                <div class="space-y-3">
                    <button id="createRoom" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-4 rounded-lg transition-colors">
                        🏠 Create Room
                    </button>
                    <div id="roomDisplay" class="hidden bg-blue-50 border border-blue-200 rounded-lg p-3">
                        <p class="text-sm text-blue-700 mb-1">Room ID:</p>
                        <div class="flex items-center gap-2">
                            <code id="roomCode" class="bg-white px-3 py-2 rounded border text-lg font-mono flex-1"></code>
                            <button id="copyRoom" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm">
                                📋 Copy
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-3">
                    <div class="flex gap-2">
                        <input id="roomInput" type="text" placeholder="Enter Room ID" 
                               class="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <button id="joinRoom" class="bg-green-600 hover:bg-green-700 text-white font-medium px-6 py-3 rounded-lg transition-colors">
                            🚪 Join
                        </button>
                    </div>
                </div>
            </div>

            <!-- Peer Status -->
            <div id="peerStatus" class="hidden bg-green-50 border border-green-200 rounded-lg p-3">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                    <span class="text-green-700 font-medium">Connected to peer</span>
                </div>
            </div>
        </div>

        <!-- File Transfer -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">📁 File Transfer</h2>
            
            <!-- Send File -->
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 mb-4 text-center">
                <input type="file" id="fileInput" class="hidden">
                <div id="dropZone" class="cursor-pointer">
                    <div class="text-4xl mb-2">📤</div>
                    <p class="text-gray-600 mb-2">Click to select a file or drag and drop</p>
                    <p class="text-sm text-gray-500">Any file type supported</p>
                </div>
            </div>
            
            <button id="sendFile" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium py-3 px-4 rounded-lg transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
                🚀 Send File
            </button>

            <!-- Transfer Progress -->
            <div id="transferProgress" class="hidden mt-4">
                <div class="flex justify-between text-sm text-gray-600 mb-1">
                    <span id="progressText">Sending...</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                    <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Received Files -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">📥 Received Files</h2>
            <div id="receivedFiles" class="space-y-2">
                <p class="text-gray-500 text-center py-4">No files received yet</p>
            </div>
        </div>

        <!-- Activity Log -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">📋 Activity Log</h2>
            <div id="log" class="bg-gray-50 rounded-lg p-4 h-48 overflow-y-auto font-mono text-sm">
                <div class="text-gray-500">Initializing connection...</div>
            </div>
        </div>
    </div>

    <script>
        class P2PFileShare {
            constructor() {
                this.peer = null;
                this.isHost = false;
                this.roomId = null;
                this.connected = false;
                
                // File transfer state
                this.sending = {
                    active: false,
                    file: null,
                    sent: 0
                };
                
                this.receiving = {
                    active: false,
                    filename: null,
                    filesize: 0,
                    chunks: [],
                    received: 0
                };

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.updateStatus('Ready to connect');
                this.log('P2P File Share initialized');
            }

            setupEventListeners() {
                // Room controls
                document.getElementById('createRoom').addEventListener('click', () => this.createRoom());
                document.getElementById('joinRoom').addEventListener('click', () => this.joinRoom());
                document.getElementById('copyRoom').addEventListener('click', () => this.copyRoomId());

                // File handling
                const fileInput = document.getElementById('fileInput');
                const dropZone = document.getElementById('dropZone');
                
                dropZone.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files[0]));
                
                // Drag and drop
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('border-blue-500', 'bg-blue-50');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                    const file = e.dataTransfer.files[0];
                    if (file) this.handleFileSelect(file);
                });

                document.getElementById('sendFile').addEventListener('click', () => this.sendFile());
            }

            createRoom() {
                this.roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                this.isHost = true;
                
                document.getElementById('roomCode').textContent = this.roomId;
                document.getElementById('roomDisplay').classList.remove('hidden');
                
                this.log(`Created room: ${this.roomId}`);
                this.updateStatus('Waiting for peer to join...');
                
                // Create peer as host (will wait for incoming connection)
                this.createPeer(false);
            }

            joinRoom() {
                const roomInput = document.getElementById('roomInput');
                this.roomId = roomInput.value.trim().toUpperCase();
                
                if (!this.roomId) {
                    alert('Please enter a room ID');
                    return;
                }
                
                this.isHost = false;
                this.log(`Joining room: ${this.roomId}`);
                this.updateStatus('Connecting to peer...');
                
                // Create peer as guest (will initiate connection)
                this.createPeer(true);
            }

            createPeer(initiator) {
                this.peer = new SimplePeer({
                    initiator: initiator,
                    trickle: false
                });

                this.peer.on('signal', (data) => {
                    this.log('Generated connection signal');
                    // In a real implementation, this would go through a signaling server
                    // For demo purposes, we'll simulate the connection
                    if (initiator) {
                        setTimeout(() => {
                            this.log('Simulating peer connection...');
                            this.simulateConnection();
                        }, 1000);
                    }
                });

                this.peer.on('connect', () => {
                    this.connected = true;
                    this.log('WebRTC connection established!');
                    this.updateStatus('Connected');
                    document.getElementById('peerStatus').classList.remove('hidden');
                    document.getElementById('sendFile').disabled = false;
                });

                this.peer.on('data', (data) => {
                    this.handleIncomingData(data);
                });

                this.peer.on('error', (err) => {
                    this.log(`Connection error: ${err.message}`);
                    this.updateStatus('Connection failed');
                });

                this.peer.on('close', () => {
                    this.connected = false;
                    this.log('Connection closed');
                    this.updateStatus('Disconnected');
                    document.getElementById('peerStatus').classList.add('hidden');
                    document.getElementById('sendFile').disabled = true;
                });
            }

            // Simulate connection for demo (in real app, this would be handled by signaling server)
            simulateConnection() {
                if (this.peer && this.peer._pc) {
                    // Simulate successful WebRTC connection
                    setTimeout(() => {
                        this.peer.emit('connect');
                    }, 500);
                }
            }

            handleFileSelect(file) {
                if (!file) return;
                
                this.sending.file = file;
                const dropZone = document.getElementById('dropZone');
                dropZone.innerHTML = `
                    <div class="text-4xl mb-2">📄</div>
                    <p class="text-gray-800 font-medium">${file.name}</p>
                    <p class="text-sm text-gray-500">${this.formatFileSize(file.size)}</p>
                `;
                
                document.getElementById('sendFile').disabled = !this.connected;
                this.log(`Selected file: ${file.name} (${this.formatFileSize(file.size)})`);
            }

            async sendFile() {
                if (!this.sending.file || !this.connected) return;
                
                const file = this.sending.file;
                this.sending.active = true;
                this.sending.sent = 0;
                
                this.log(`Starting file transfer: ${file.name}`);
                this.showProgress(true, 'Sending');
                
                // Send file metadata
                const metadata = {
                    type: 'file-start',
                    filename: file.name,
                    filesize: file.size,
                    filetype: file.type
                };
                
                this.peer.send(JSON.stringify(metadata));
                
                // Send file in chunks
                const CHUNK_SIZE = 16 * 1024; // 16KB chunks
                let offset = 0;
                
                const sendChunk = async () => {
                    if (offset >= file.size) {
                        this.peer.send(JSON.stringify({ type: 'file-end' }));
                        this.sending.active = false;
                        this.showProgress(false);
                        this.log('File transfer completed');
                        return;
                    }
                    
                    const chunk = file.slice(offset, offset + CHUNK_SIZE);
                    const arrayBuffer = await chunk.arrayBuffer();
                    
                    this.peer.send(arrayBuffer);
                    offset += CHUNK_SIZE;
                    this.sending.sent = Math.min(offset, file.size);
                    
                    const progress = (this.sending.sent / file.size) * 100;
                    this.updateProgress(progress, `Sending ${file.name}`);
                    
                    // Continue sending next chunk
                    setTimeout(sendChunk, 10);
                };
                
                sendChunk();
            }

            handleIncomingData(data) {
                try {
                    // Try to parse as JSON (metadata)
                    const message = JSON.parse(data);
                    
                    if (message.type === 'file-start') {
                        this.receiving = {
                            active: true,
                            filename: message.filename,
                            filesize: message.filesize,
                            filetype: message.filetype,
                            chunks: [],
                            received: 0
                        };
                        
                        this.log(`Receiving file: ${message.filename} (${this.formatFileSize(message.filesize)})`);
                        this.showProgress(true, 'Receiving');
                    } else if (message.type === 'file-end') {
                        this.completeFileReceive();
                    }
                } catch (e) {
                    // Binary data (file chunk)
                    if (this.receiving.active) {
                        this.receiving.chunks.push(new Uint8Array(data));
                        this.receiving.received += data.byteLength;
                        
                        const progress = (this.receiving.received / this.receiving.filesize) * 100;
                        this.updateProgress(progress, `Receiving ${this.receiving.filename}`);
                    }
                }
            }

            completeFileReceive() {
                if (!this.receiving.active) return;
                
                // Combine all chunks into a single blob
                const blob = new Blob(this.receiving.chunks, { type: this.receiving.filetype });
                const url = URL.createObjectURL(blob);
                
                // Add to received files list
                this.addReceivedFile(this.receiving.filename, this.receiving.filesize, url);
                
                this.log(`File received: ${this.receiving.filename}`);
                this.showProgress(false);
                
                // Reset receiving state
                this.receiving = {
                    active: false,
                    filename: null,
                    filesize: 0,
                    chunks: [],
                    received: 0
                };
            }

            addReceivedFile(filename, filesize, downloadUrl) {
                const container = document.getElementById('receivedFiles');
                
                // Remove "no files" message
                if (container.children.length === 1 && container.children[0].textContent.includes('No files')) {
                    container.innerHTML = '';
                }
                
                const fileElement = document.createElement('div');
                fileElement.className = 'flex items-center justify-between bg-gray-50 rounded-lg p-3 border';
                fileElement.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="text-2xl">📄</div>
                        <div>
                            <div class="font-medium text-gray-800">${filename}</div>
                            <div class="text-sm text-gray-500">${this.formatFileSize(filesize)}</div>
                        </div>
                    </div>
                    <a href="${downloadUrl}" download="${filename}" 
                       class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        💾 Download
                    </a>
                `;
                
                container.appendChild(fileElement);
            }

            copyRoomId() {
                const roomCode = document.getElementById('roomCode').textContent;
                navigator.clipboard.writeText(roomCode).then(() => {
                    const button = document.getElementById('copyRoom');
                    const originalText = button.textContent;
                    button.textContent = '✅ Copied!';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 2000);
                });
            }

            showProgress(show, text = '') {
                const progressDiv = document.getElementById('transferProgress');
                if (show) {
                    progressDiv.classList.remove('hidden');
                    document.getElementById('progressText').textContent = text;
                } else {
                    progressDiv.classList.add('hidden');
                }
            }

            updateProgress(percent, text) {
                document.getElementById('progressPercent').textContent = `${Math.round(percent)}%`;
                document.getElementById('progressBar').style.width = `${percent}%`;
                document.getElementById('progressText').textContent = text;
            }

            updateStatus(status) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = status;
                
                // Update status styling
                statusEl.className = 'px-3 py-1 rounded-full text-sm font-medium';
                if (status.includes('Connected')) {
                    statusEl.classList.add('bg-green-100', 'text-green-700');
                } else if (status.includes('failed') || status.includes('Disconnected')) {
                    statusEl.classList.add('bg-red-100', 'text-red-700');
                } else if (status.includes('Connecting') || status.includes('Waiting')) {
                    statusEl.classList.add('bg-yellow-100', 'text-yellow-700');
                } else {
                    statusEl.classList.add('bg-gray-100', 'text-gray-600');
                }
            }

            log(message) {
                const logEl = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'text-gray-700 mb-1';
                logEntry.textContent = `${timestamp} - ${message}`;
                
                logEl.insertBefore(logEntry, logEl.firstChild);
                
                // Keep only last 50 log entries
                while (logEl.children.length > 50) {
                    logEl.removeChild(logEl.lastChild);
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Initialize the application
        new P2PFileShare();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'972416e0309291b5',t:'MTc1NTcxNTk2My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>